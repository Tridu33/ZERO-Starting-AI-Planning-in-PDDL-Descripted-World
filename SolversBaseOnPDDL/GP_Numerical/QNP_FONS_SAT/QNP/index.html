<!DOCTYPE html><html> <head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=author content=tridu33><link rel="shortcut icon" href=../../../../img/favicon.ico><title>QNP &mdash; AI Planning in PDDL-Descripted World</title><link rel=stylesheet href="//fonts.googleapis.com/css?family=Lato:400,700"><link rel=stylesheet href=//cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css><link rel=stylesheet href=//use.fontawesome.com/releases/v5.8.1/css/all.css><link rel=stylesheet href=//use.fontawesome.com/releases/v5.8.1/css/v4-shims.css><link rel=stylesheet href=../../../../css/theme.css><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css><script src=//code.jquery.com/jquery-2.1.1.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js></script><script>
        hljs.initHighlightingOnLoad();
    </script></head> <body ontouchstart> <div id=container> <aside> <div class=home> <div class=title> <button class=hamburger></button> <a href=../../../.. class=site-name> AI Planning in PDDL-Descripted World</a> </div> <div class=search> <div role=search> <form id=rtd-search-form class=wy-form action=../../../../search.html method=get> <input type=text name=q placeholder="Search docs" title="Type search term here"> </form> </div> </div> </div> <nav class=nav> <ul class=root> <li class=toctree-l1><a class=nav-item href=../../../..>Home</a></li> <li class=toctree-l1><button class="section nav-item">规划界黑话</button> <ul class=subnav> <li class=toctree-l2><button class="section nav-item hide">PDDL进化史</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../../../PlanLanguages/PDDL%E8%AF%AD%E8%A8%80/ class=nav-item>HelloPDDL</a></li> <li class=toctree-l3><a href=../../../../PlanLanguages/PDDL_basic/ class=nav-item>PDDL-Basic</a></li> <li class=toctree-l3><a href=../../../../PlanLanguages/ADL/ class=nav-item>ADL</a></li> <li class=toctree-l3><a href=../../../../PlanLanguages/STRIPS%E8%AF%AD%E8%A8%80/ class=nav-item>STRIPS</a></li> <li class=toctree-l3><button class="section nav-item hide">PDDL</button> <ul class="subnav hide"> <li class=toctree-l4><a href=../../../../PlanLanguages/Extension%20to%20PDDL/ class=nav-item>PDDL扩展</a></li> <li class=toctree-l4><a href=../../../../PlanLanguages/FOND-QNP%28SAS%2B%29/ class=nav-item>FOND-QNP(SAS+)</a><a href=../../../../PlanLanguages/FOND-QNP%28SAS%2B%29/ class=nav-item>FOND-QNP(SAS+)</a></li> </ul></li> <li class=toctree-l3><a href=../../../../PlanLanguages/lowLevelVShighLevel/ class=nav-item>相同问题不同表示手法对比</a><a href=../../../../PlanLanguages/lowLevelVShighLevel/ class=nav-item>相同问题不同表示手法对比</a></li> </ul></li> <li class=toctree-l2><button class="section nav-item hide">机器人世界</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../../../PlanLanguages/Golog/Golog_ROS/ class=nav-item>Golog</a></li> </ul></li> </ul></li> <li class=toctree-l1><button class="section nav-item">PDDL使用</button> <ul class=subnav> <li class=toctree-l2> <a href=../../../../Usage/LocalSolvers/ class=nav-item>本地环境使用</a></li> <li class=toctree-l2> <a href=../../../../Usage/OnlineSolver/ class=nav-item>线上求解器使用</a></li> <li class=toctree-l2> <a href=../../../../Usage/VSCode/ class=nav-item>Visual Studio Code使用</a></li> <li class=toctree-l2><a href=../../../../Usage/FFPlanner_demo/ class=nav-item>ffPlanner_demo</a></li> <li class=toctree-l2><button class="section nav-item hide">经典demos</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../../%E5%88%8A%E7%89%A9%E4%B8%8A%E7%BB%8F%E5%85%B8demos/ class=nav-item>刊物上经典demos</a></li> <li class=toctree-l3><a href=../../../PDDL%20Benchmark%20Instances/ class=nav-item>BenchMark</a></li> </ul></li> </ul></li> <li class=toctree-l1><button class="section nav-item">PDDL语法</button> <ul class=subnav> <li class=toctree-l2> <a href=../../../../Syntax/PDDL%20axioms/ class=nav-item>语法总览</a></li> <li class=toctree-l2><a href=../../../../Syntax/PDDLParser/ class=nav-item>Parser</a></li> </ul></li> <li class=toctree-l1><button class="section nav-item">PDDL-Descripted AI Planning World</button> <ul class=subnav> <li class=toctree-l2><button class="section nav-item hide">Papers</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../../../Papers/A%20review%20of%20generalized%20planning/ class=nav-item>reviewOfGP</a></li> <li class=toctree-l3><a href=../../../../Papers/GP_summary/ class=nav-item>GP_summary</a></li> <li class=toctree-l3><a href=../../../../Papers/A%20Review%20of%20Machine%20Learning%20for%20Automated%20Planning/ class=nav-item>ReviewOfMLforAP</a></li> <li class=toctree-l3><a href=../../../../Papers/Generalized%20Planning%20With%20Deep%20Reinforcement%20Learning/ class=nav-item>GPwithDeep-RL</a></li> <li class=toctree-l3><a href=../../../../Papers/Survey%20of%20research%20literature/ class=nav-item>researchSurvey</a></li> </ul></li> <li class="toctree-l2 current"><button class="section nav-item">SolversBaseOnPDDL</button> <ul class=subnav> <li class=toctree-l3><a href=../../../PyperPlan_STRIPS/ class=nav-item>PyperPlan_STRIPS</a></li> <li class=toctree-l3><a href=../../../Solvers/ class=nav-item>Solvers</a></li> <li class=toctree-l3><button class="section nav-item hide">CP</button> <ul class="subnav hide"> <li class=toctree-l4><a href=../../../CP/ffPlaner/ class=nav-item>FF</a></li> <li class=toctree-l4><a href=../../../CP/fast-downward/ class=nav-item>FD</a></li> <li class=toctree-l4><a href=../../../CP/LAPKT%E8%BD%BB%E9%87%8F%E8%87%AA%E5%8A%A8%E8%A7%84%E5%88%92%E5%B7%A5%E5%85%B7%E5%8C%85/ class=nav-item>LAPKT轻量自动规划工具包</a></li> </ul></li> <li class=toctree-l3><button class="section nav-item hide">GP_Numerical</button> <ul class="subnav hide"> <li class=toctree-l4> <a href=../../QNP_ReduceTo_GraphProblem/ class=nav-item>QNP_ReduceTo_GraphProblem</a></li> <li class=toctree-l4><a href=../../%E5%9B%BE%E6%B3%95QNP/ class=nav-item>图法QNP</a></li> <li class=toctree-l4><a href=../../LPG%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E8%A7%84%E5%88%92%E5%9B%BE%EF%BC%89/ class=nav-item>LPG</a></li> <li class=toctree-l4><a href=../../grahPlan/ class=nav-item>grahPlan</a></li> <li class=toctree-l4><a href=../../SGPlan6/ class=nav-item>SGPlan6</a></li> <li class=toctree-l4><a href=../../PRP/ class=nav-item>PRP</a></li> <li class=toctree-l4><a href=../../myND/ class=nav-item>myND</a></li> </ul></li> <li class="toctree-l3 current"><button class="section nav-item">QNP_FONS_SAT</button> <ul class=subnav> <li class=toctree-l4><a href=../CNF_py/ class=nav-item>CNF_py</a></li> <li class=toctree-l4><a href=../FOND/ class=nav-item>FOND</a></li> <li class=toctree-l4><a href=../QA_FOND/ class=nav-item>QA_FOND</a></li> <li class=toctree-l4><a href=../%E4%BE%8B%E8%A7%A3FOND%2BCNF/ class=nav-item>例解FOND</a></li> <li class="toctree-l4 current"><a href=./ class="nav-item current">QNP</a> <ul class=subnav> <li class=toctree-l5><a class="nav-item toc" href=#qnp2fond>首先qnp2fond</a></li> <li class=toctree-l5><a class="nav-item toc" href=#fond-sat>然后fond-sat</a></li> <li class=toctree-l5><a class="nav-item toc" href=#fondqnp>FOND互相转换QNP</a></li> <li class=toctree-l5><a class="nav-item toc" href=#q_clear-block-world>\(Q_{clear}\) Block world</a></li> <li class=toctree-l5><a class="nav-item toc" href=#gripper>Gripper</a></li> <li class=toctree-l5><a class="nav-item toc" href=#related-work>related work</a></li> </ul></li> <li class=toctree-l4><a href=../qnp2fond/ class=nav-item>qnp2fond</a></li> <li class=toctree-l4><a href=../QNP2SAT/ class=nav-item>QNP2SAT</a></li> </ul></li> </ul></li> <li class=toctree-l2><button class="section nav-item hide">PDDL-plan-validators</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../../../Extensions/PDDL-plan-validator/PDDL-plan-validator/ class=nav-item>validators</a></li> <li class=toctree-l3><a href=../../../../Extensions/PDDL-plan-validator/Lisp-pddl-INVAL-validator/ class=nav-item>INVAL</a></li> <li class=toctree-l3><a href=../../../../Extensions/PDDL-plan-validator/VScode-PDDL%E6%8F%92%E4%BB%B6VAL/ class=nav-item>VAL</a></li> </ul></li> <li class=toctree-l2><button class="section nav-item hide">PDDL-Auto Planning</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../../../Extensions/AP/PDDL4j_Java%20for%E8%87%AA%E5%8A%A8%E8%A7%84%E5%88%92/ class=nav-item>PDDL4j</a></li> <li class=toctree-l3><a href=../../../../Extensions/AP/Tarski%20-%20An%20AI%20Planning%20Modeling%20Framework/ class=nav-item>Tarski</a></li> <li class=toctree-l3><a href=../../../../Extensions/AP/%E5%AE%9E%E4%BE%8B%E4%B8%AD%E5%AD%A6%E4%B9%A0QNP%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0AP%28AutomatedPlanning%29/ class=nav-item>QNP2AP</a></li> <li class=toctree-l3><a href=../../../../Extensions/RL/PDDLGYM/ class=nav-item>PDDLGYM</a></li> <li class=toctree-l3><a href=../../../../Extensions/RL/RLPlanPapers/ class=nav-item>PDDL+RL强化学习</a></li> </ul></li> </ul></li> <li class=toctree-l1><button class="section nav-item">进击的PDDL</button> <ul class=subnav> <li class=toctree-l2><button class="section nav-item hide">Curry-Howard correspondence</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../../../FurtherMore/%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BECFG%E8%AF%AD%E4%B9%89%E7%BD%91%E7%BB%9Cpetri%E8%BF%81%E7%A7%BB%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8/ class=nav-item>CFG语义网络</a></li> <li class=toctree-l3><a href=../../../../FurtherMore/PDDL-Solver2AST/ class=nav-item>PDDL-Solver2AST</a></li> <li class=toctree-l3><a href=../../../../FurtherMore/TransitionSystemModelCheck/ class=nav-item>CFG=TransitionSystemModelCheck.md</a></li> <li class=toctree-l3><a href=../../../../FurtherMore/qnp2ast2program/ class=nav-item>qnp2ast2program</a></li> </ul></li> </ul></li> <li class=toctree-l1> <a class=nav-item href=https://github.com/Tridu33/ZERO-Starting-AI-Planning-in-PDDL-Descripted-World/issues>Issue跟踪讨论</a></li> </ul> </nav> <div class=repo> <div class=link> </div> <div class=previous><a href=../%E4%BE%8B%E8%A7%A3FOND%2BCNF/ >&laquo; Previous</a></div> <div class=next><a href=../qnp2fond/ >Next &raquo;</a></div> </div> </aside> <div id=spacer><button class=arrow></button></div> <main> <div class=home-top> <button class=hamburger></button> <a href=../../../.. class=site-name> AI Planning in PDDL-Descripted World</a> </div> <div id=main> <nav class=breadcrumbs> <ul> <li>PDDL-Descripted AI Planning World &raquo; </li><li>SolversBaseOnPDDL &raquo; </li><li>QNP_FONS_SAT</li> </ul> </nav> <div id=content><div class=toc> <ul> <li><a href=#qnp>QNP</a><ul> <li><a href=#qnp2fond>首先qnp2fond</a></li> <li><a href=#fond-sat>然后fond-sat</a></li> <li><a href=#fondqnp>FOND互相转换QNP</a></li> <li><a href=#q_clear-block-world>\(Q_{clear}\) Block world</a><ul> <li><a href=#_1>一个变量</a></li> <li><a href=#_2>两个变量</a></li> </ul> </li> <li><a href=#gripper>Gripper</a></li> <li><a href=#related-work>related work</a></li> </ul> </li> </ul> </div> <h1 id=qnp>QNP<a class=headerlink href=#qnp title="Permanent link">&para;</a></h1> <p>groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1</p> <p>原qnp问题Q</p> <div class=highlight><pre><span></span><code>grid
2 delta(X) 1 delta(Y) 1
2 delta(X) 1 delta(Y) 1
2 delta(X) 0 delta(Y) 0
2
Move-in-row
1 delta(X) 1
1 delta(X) 0
Move-in-column
1 delta(Y) 1
1 delta(Y) 0
</code></pre></div> <h2 id=qnp2fond>首先qnp2fond<a class=headerlink href=#qnp2fond title="Permanent link">&para;</a></h2> <p>The translator is invoked using</p> <div class=highlight><pre><span></span><code>qnp2fond &lt;qnp-file&gt; &lt;counter-capacity&gt; &lt;loop-nesting&gt; &lt;prefix&gt;
</code></pre></div> <p>where the first argument is the name of a .qnp file (see below), the two additional arguments are non-negative integers, typicall small ones such as 0, 1 or 2, and the last argument is the prefix for the generated files (domain and problem files).</p> <div class=highlight><pre><span></span><code>./qnp2fond ./grid.qnp 2 2 grid_output
</code></pre></div> <h2 id=fond-sat>然后fond-sat<a class=headerlink href=#fond-sat title="Permanent link">&para;</a></h2> <div class=highlight><pre><span></span><code>usage: main.py [-h] [-time_limit TIME_LIMIT] [-mem_limit MEM_LIMIT]
               [-name_temp NAME_TEMP] [-strong STRONG] [-inc INC]
               [-gen_info GEN_INFO] [-policy POLICY]
               path_domain path_instance
</code></pre></div> <div class=highlight><pre><span></span><code>python main.py ../F-domains/islands/domain.pddl ../F-domains/islands/p03.pddl -strong 1 -inc 2 -policy 1
</code></pre></div> <p>自动化求解过程：</p> <div class=highlight><pre><span></span><code>python  main.py ../qnp2fond_examples/grid_output_d.pddl  ../qnp2fond_examples/grid_output_p.pddl -strong 1 -inc 2 -policy 1
</code></pre></div> <p><a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/ >https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/</a></p> <p><img alt src=../_v_images/1597376914_16967.png></p> <p>基本上，共享一组相同动作和状态特征的计划实例*P的*实例通常可以表示为单个QNP问题*Q，*其解决方案将状态特征映射为动作，然后解决Q中的所有问题（Bonet＆Geffner，2018）。</p> <p>QNP可以通过两个步骤解决（Srivastava等，2011）。</p> <ol> <li> <p>首先，将QNP Q转换为标准的完全可观察的非确定性（FOND）问题P（Cimatti，Pistore，Roveri和Traverso，2003年）。 </p> </li> <li> <p>然后，测试由现成的FOND规划器获得的P的解是否**终止**。这最后一步是必需的，因为FOND问题P中的不确定性是unfair，但在条件上是fair：如果X的增加不超过有限数，则数值变量X的无穷定性减量最终使表达式X = 0成立。 （Bonet，De Giacomo，Geffner和Rubin，2017年）。</p> </li> </ol> <p>那么，解决P 并终止的策略就是解决QNP Q 的策略（Srivastava et al。，2011）。</p> <p>但是，遵循这种生成和测试方法解决QNP的计算缺点是两个。 - 首先，修改FOND计划者以生成FOND问题的所有解决方案并不容易，因为FOND计划不是行​​动序列而是闭环策略。 - 其次，需要测试终止的策略的数量可能非常庞大：FOND状态的数量呈指数形式，因此变量数量成倍增加。</p> <p>经典的计划问题是一个顺序决策问题，在该问题中，要通过从给定初始状态执行具有确定性作用的动作来达到目标​​。这些问题通常以诸如STRIPS（Fikes和Nilsson，1971； Russell和Norvig，2002）之类的计划语言以紧凑的形式表达。</p> <p>一个（扎根的）STRIPS计划问题（带有否定）是一个元组P = <em>{F，I，O，G）</em> ，其中*F* 表示一组命题变量，<em>I</em> 和*G* 是*F的*集合，代表初始和目标情况， O是一组动作a，其前提条件和效果*是*由F字词集给定的Pre（a）和 <em>Eff（a）</em></p> <p>问题P = {F，I，O，G）的状态模型S（P ）是元组S（P ）= {S，s〇，Act，A，f，Sg ），</p> <p>其中S 是可能的集合真估值在F文字，称为状态，š 〇是初始状态，ACT = O，A（s）表示在动作，其先决条件是在S，F（A，S）真表示状态s的动作的在GA的动作a in s之后的，而Sg是目标状态的集合。假设问题P在s〇和f定义明确且Sg不为空的意义上是一致的。</p> <p>经典问题P的解决方案是动作序列</p> <p>由FOND问题P = {F，I，O，G）确定的状态模型S（P）是一个元组S（P）= {S，s〇，Act，A，F，SG）**状态转移函数F**是不确定的，并且将动作a和状态s映射到可能的后续状态的非空集F（a，s）。像往常一样，不确定性转换函数F 以分解形式给出。也就是说，行动一由多种效果制成Eff x | •••| Eff n（可能是确定的，当n = 1时），F（a，s）中的每个结果s'为a的每个不确定性效应选择一个Effi的结果<span class=arithmatex>\(^2\)</span></p> <p>石头世界：</p> <p><span class=arithmatex>\(Q_{clear} =\)</span> <f,v,i,o,g></p> <p>F,{H}</p> <p>V,{n(x)}</p> <p>I,{<span class=arithmatex>\(\neg H\)</span>,n(x)&gt;0}</p> <p>O,{a,b}, a=&lt; <span class=arithmatex>\(\neg H\)</span>,n(x)&gt;0;H,n(x)<span class=arithmatex>\(\downarrow\)</span>&gt;, b=<h;&lt;span class=arithmatex>\(\neg H\)</span>></p> <p>G={n(x)=0}</p> <div class=mermaid>graph LR; 　　&#172H,n&gt0 -->|a动作n&#8595| H,N&#8595仍&gt0; 　　H,N&#8595仍&gt0 -->|b动作&#172H|&#172H,n&gt0; 　　H,N&#8595仍&gt0 -->|a动作n&#8595| n=0 ; </div> <p><span class=arithmatex>\(Q_{nest} =\)</span> <f,v,i,o,g></p> <p>F,{<span class=arithmatex>\(\oslash\)</span>}</p> <p>V,{X,Y}</p> <p>I,{X&gt;0,Y&gt;0;}</p> <p>O,{a,b}, a=\&lt; X&gt;0,Y=0;X<span class=arithmatex>\(\downarrow\)</span>Y<span class=arithmatex>\(\uparrow\)</span> >, b=\<y>0; Y<span class=arithmatex>\(\downarrow\)</span> ></p> <p>G={X=0}</p> <p><div class=mermaid>graph LR; 　　X&gt0,Y&gt0 -->|b动作Y&#8595| X&gt0,Y&gt0; 　　X&gt0,Y&gt0 -->|b动作Y&#8595| X&gt0,Y=0; 　　X&gt0,Y=0 -->|a动作X&#8595Y&#8593| X&gt0,Y&gt0 ; 　　X&gt0,Y=0 -->|a动作X&#8595Y&#8593| X=0,Y&gt0 ; </div> 要保证fair，有的不确定性动作情况下不能无限死磕一个循环不出来，这题确定性deterministic。</p> <p>Y循环nest loop(strong cyclic solutions/infinite)，X的单调递减finite归零可证。</p> <p>就像《范畴学》的图</p> <ol> <li> <p>QNP问题Q=\&lt; F,V,I,O,G >根据公式Definition直接翻译得到FOND问题P=<span class=arithmatex>\(T_D(Q)\)</span>=\&lt; F',I',O',G' ></p> </li> <li> <p>F ′ = F ∪ {X = 0 : X ∈ V }, where X = 0 stands for a new propositional symbol pX = 0 and X &gt; 0 stands for ¬pX = 0,</p> </li> <li>I ′ = I but with X = 0 and X &gt; 0 denoting pX = 0 and ¬pX = 0</li> <li>O′ = O but with Inc(X) effects replaced by the deterministic propositional effects X &gt; 0, and Dec(X) effects replaced by non-deterministic propositional effects X &gt; 0 | X = 0,</li> <li>G′ = G but with X = 0 and X &gt; 0 denoting pX = 0 and ¬pX = 0</li> </ol> <p>从这个图开始出发：</p> <div class=mermaid>graph LR; 　　X&gt0,Y&gt0 -->|b动作Y&#8595| X&gt0,Y&gt0; 　　X&gt0,Y&gt0 -->|b动作Y&#8595| X&gt0,Y=0; 　　X&gt0,Y=0 -->|a动作X&#8595Y&#8593| X&gt0,Y&gt0 ; 　　X&gt0,Y=0 -->|a动作X&#8595Y&#8593| X=0,Y&gt0 ; </div> <p>步骤： 1. 文字X=0和X&gt;0写成数值变量X的eliminated,x=0表示<span class=arithmatex>\(P_X\)</span>=0,而X&gt;0表示<span class=arithmatex>\(\neg P_X\)</span>=0,我理解是非零即真，这里当作一种标识True，认为建模目标令控制变量X=0 2. <span class=arithmatex>\(In_c(x)\)</span>代表 确定性后续命题效果X&gt;0,比如上图动作b箭头后续都是X&gt;0; 3. <span class=arithmatex>\(Dec(x)\)</span>代表 确定性后续命题效果<code>X&gt;0|X=0</code> ,即<span class=arithmatex>\(P_X=0 | \neg P_X=0\)</span>,还是上图,a为例子的话就是a箭头有可能指向X&gt;0|X=0;</p> <p>重点在于：</p> <ol> <li>FOND也能归约到QNP,相同复杂性</li> </ol> <p>Sieve算法</p> <p>先深度优先找出SCC结点集合（第一个第二个，出发能遍历所有点回到自身的节点）</p> <p>然后去除SCC结点出发,Dec(x)的箭头，Not increase的。</p> <p>最后剩下的看是不是acyclic，是则terminate，否则循环</p> <p><img alt src=../_v_images/1594908128_29744.png></p> <h2 id=fondqnp>FOND互相转换QNP<a class=headerlink href=#fondqnp title="Permanent link">&para;</a></h2> <p>跟着 Bonet 文章介绍的转</p> <h2 id=q_clear-block-world><span class=arithmatex>\(Q_{clear}\)</span> Block world<a class=headerlink href=#q_clear-block-world title="Permanent link">&para;</a></h2> <h3 id=_1>一个变量<a class=headerlink href=#_1 title="Permanent link">&para;</a></h3> <p>积木世界</p> <p><img alt=Q_clear src=../_v_images/q_clear_1597996912_12064.png></p> <h3 id=_2>两个变量<a class=headerlink href=#_2 title="Permanent link">&para;</a></h3> <p>积木世界接龙版</p> <p><img alt=Q_clearProblem src=../_v_images/q_clearpro_1597997815_4139.png></p> <p><img alt=QNP2FOND然后用FOND-SAT求出来的 src=../_v_images/fondsat%E6%B1%82%E5%87%BA%E6%9D%A5_1597996983_13429.png></p> <p>感觉不一定清理完X上的n个积木，再请开y上的m个积木，</p> <p>也可能是先y后x</p> <p>更可能是像下面这样x，y混合着来：</p> <p><img alt=好像更可能发生的搬运方法 src=../_v_images/%E5%AE%9E%E9%99%85%E7%9A%84%E8%A7%A3%E6%B3%95_1597996702_15152.png></p> <h2 id=gripper>Gripper<a class=headerlink href=#gripper title="Permanent link">&para;</a></h2> <p><img alt=GrippersProblem src=../_v_images/gripperspr_1597997846_3160.png></p> <p><img alt=用FOND-SAT求解的Gripper src=../_v_images/1597997057_22453.png></p> <h2 id=related-work>related work<a class=headerlink href=#related-work title="Permanent link">&para;</a></h2> <p>QNPs have been introduced as a decidable planning model able to account for plans with loops [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx45>Srivastava, Zilberstein, Immerman, GeffnerSrivastava et al.2011</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx44>Srivastava, Zilberstein, Gupta, Abbeel, RussellSrivastava et al.2015</a>]. In addition, by defining the boolean and numerical variables of QNPs as suitable general boolean and numerical features over a given domain, it has been shown that QNPs can be used to express abstract models for generalized planning, in particular when the ground actions change from instance to instance [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx10>Bonet GeffnerBonet Geffner2018</a>]. More recently, it has been shown that these QNP abstractions can be learned automatically from a given planning domain and sampled plans [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx8>Bonet, Francès, GeffnerBonet et al.2019</a>]. QNPs thus provide a convenient language for a model-based approach for the computation of general plans where such plans are derived from a (QNP) planning model. If the model is sound, the general plans are guaranteed to be correct [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx10>Bonet GeffnerBonet Geffner2018</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx8>Bonet, Francès, GeffnerBonet et al.2019</a>]. This is contrast with the more common inductive or learning-based approaches where plans computed to solve a few sampled instances are assumed to generalize to other instances by virtue of the compact form of the plans [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx31>KhardonKhardon1999</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx34>Martin GeffnerMartin Geffner2004</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx18>Fern, Yoon, GivanFern et al.2004</a>]. These learning approaches do not construct or solve a suitable abstraction of the problems as expressed by QNPs. Inductive approaches have been used recently to learn general plans in the form of finite-state controllers [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx6>Bonet, Palacios, GeffnerBonet et al.2009</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx26>Hu De GiacomoHu De Giacomo2013</a>], finite programs [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx1>Aguas, Celorrio, , JonssonAguas et al.2016</a>], and deep neural nets learned in a supervised manner [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx48>Toyer, Trevizan, Thiébaux, XieToyer et al.2018</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx13>Bueno, de Barros, Mauá, SannerBueno et al.2019</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx29>Issakkimuthu, Fern, TadepalliIssakkimuthu et al.2018</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx3>Bajpai, Garg, et al.Bajpai et al.2018</a>]. A key difference between learning-based and model-based approaches is that the correctness of the latter follows from the soundness of the model. Deep reinforcement learning methods have also been used recently for computing generalized plans with no supervision [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx24>Groshev, Goldstein, Tamar, Srivastava, AbbeelGroshev et al.2018</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx46>Sukhbaatar, Szlam, Synnaeve, Chintala, FergusSukhbaatar et al.2015</a>], yet by not using first-order symbolic representations, they have difficulties in dealing with relational domains that involve objects and relations [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx20>Garnelo ShanahanGarnelo Shanahan2019</a>]. Forms of generalized planning have also been formulated using first-order logic [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx43>Srivastava, Immerman, ZilbersteinSrivastava et al.2011</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx28>Illanes McIlraithIllanes McIlraith2019</a>], and general plans over finite horizons have been derived using first-order regression as well [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx12>Boutilier, Reiter, PriceBoutilier et al.2001</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx50>Wang, Joshi, KhardonWang et al.2008</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx49>Van OtterloVan Otterlo2012</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx41>Sanner BoutilierSanner Boutilier2009</a>]. The use of QNPs for expressing (or learning) abstractions for generalized planning problems, combined with the compilation of QNPs into FOND problems, allows us to benefit from the performance of propositional off-the-shelf FOND planners like PRP [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx35>Muise, McIlraith, BeckMuise et al.2012</a>], MyND [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx5>Bercher MattmüllerBercher Mattmüller2009</a>], or FOND-SAT [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx22>Geffner GeffnerGeffner Geffner2018</a>] in order to find policies for generalized planning.</p> <p>QNP planning problems can be easily translated into LTL planning problems with FOND domains, reachability goals, and a particular type of trajectory constraints that can be expressed as compact LTL formula [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx7>Bonet, De Giacomo, Geffner, RubinBonet et al.2017</a>]. The trajectory constraints use a fragment of LTL [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx37>PnueliPnueli1977</a>] to express the QNP fairness constraints; namely, that for each numerical variable X in a QNP, it is always the case that infinite decrements of X combined with finite increments of X must eventually drive the variable X to 0. As a result, QNP planning can be translated quite efficiently (linear time) into LTL synthesis. The translation, however, is not particularly useful computationally, as QNP planning, like FOND planning, is EXP-Complete, while LTL synthesis is 2EXP-Complete (doubly exponential in time) [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx38>Pnueli RosnerPnueli Rosner1989</a>]. In LTL planning, i.e., FOND planning with LTL goals and trajectory constraints, the double exponential growth is in the number of variables that appear in such formulas [<a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx14>Camacho, Bienvenu, McIlraithCamacho et al.2019</a>, <a href=https://www.groundai.com/project/qualitative-numeric-planning-reductions-and-complexity/1#bib.bibx2>Aminof, Giacomo, Murano, RubinAminof et al.2019</a>].</p> <p>For the specific type of LTL trajectory constraints that QNPs convey, the general method of bonet:ijcai2017 bonet:ijcai2017 results in an EXPSPACE algorithm for the synthesis of a tree automaton that solves the given QNP (or to determine that such automaton does not exist). Indeed, the method first computes a deterministic parity word (DPW) automaton that accepts the models of an LTL formula that captures the QNP; this automaton may be of doubly exponential size and with an exponential number of priorities for general types of LTL trajectory constraints, but it is “only” of exponential size and with a bounded number of priorities for QNPs. Then, a deterministic parity tree automaton At, that accepts the policies for the QNP and is built from the DPW automaton, must be tested for non-emptiness. The tree automaton At has size that is polynomial in the size of the DPW automaton and with the same number of priorities. The non-emptiness test requires time that is polynomial in the size of At but exponential in the number of priorities. For QNPs, the number of priorities is bounded and thus this method can be implemented in exponential space since the DPW automaton must be <em>explicitly</em> built. Like the reduction from QNPs into FOND problems, this method does not solve the question posed above about the solvability of QNPs by memoryless policies since the automaton At captures all history-based policies for the input QNP, not only memoryless policies.</p></div> <footer> <div class=footer-buttons> <div class=previous><a href=../%E4%BE%8B%E8%A7%A3FOND%2BCNF/ title=例解FOND><span>Previous</span></a></div> <div class=next><a href=../qnp2fond/ title=qnp2fond><span>Next</span></a></div> </div> <div class=footer-note> <p> Built with <a href=http://www.mkdocs.org>MkDocs</a> using <a href=https://github.com/daizutabi/mkdocs-ivory>Ivory theme</a>. </p> </div> </footer> </div> </main> </div> <script>var base_url = '../../../..';</script> <script src=../../../../js/theme.js></script> <script src=../../../../js/umlconvert.js></script> <script src=../../../../js/sequence-loader.js></script> <script src=https://unpkg.com/mermaid/dist/mermaid.min.js></script> <script src=https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js></script> <script src=https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.12.0/underscore-min.js></script> <script src=https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js></script> <script src=https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js></script> <script src=../../../../search/main.js></script> </body> </html>