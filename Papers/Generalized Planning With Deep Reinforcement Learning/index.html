<!DOCTYPE html><html> <head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=author content=tridu33><link rel="shortcut icon" href=../../img/favicon.ico><title>GPwithDeep-RL &mdash; AI Planning in PDDL-Descripted World</title><link rel=stylesheet href="//fonts.googleapis.com/css?family=Lato:400,700"><link rel=stylesheet href=//cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css><link rel=stylesheet href=//use.fontawesome.com/releases/v5.8.1/css/all.css><link rel=stylesheet href=//use.fontawesome.com/releases/v5.8.1/css/v4-shims.css><link rel=stylesheet href=../../css/theme.css><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css><script src=//code.jquery.com/jquery-2.1.1.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js></script><script>
        hljs.initHighlightingOnLoad();
    </script></head> <body ontouchstart> <div id=container> <aside> <div class=home> <div class=title> <button class=hamburger></button> <a href=../.. class=site-name> AI Planning in PDDL-Descripted World</a> </div> <div class=search> <div role=search> <form id=rtd-search-form class=wy-form action=../../search.html method=get> <input type=text name=q placeholder="Search docs" title="Type search term here"> </form> </div> </div> </div> <nav class=nav> <ul class=root> <li class=toctree-l1><a class=nav-item href=../..>Home</a></li> <li class=toctree-l1><button class="section nav-item">规划界黑话</button> <ul class=subnav> <li class=toctree-l2><button class="section nav-item hide">PDDL进化史</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../PlanLanguages/PDDL%E8%AF%AD%E8%A8%80/ class=nav-item>HelloPDDL</a></li> <li class=toctree-l3><a href=../../PlanLanguages/PDDL_basic/ class=nav-item>PDDL-Basic</a></li> <li class=toctree-l3><a href=../../PlanLanguages/ADL/ class=nav-item>ADL</a></li> <li class=toctree-l3><a href=../../PlanLanguages/STRIPS%E8%AF%AD%E8%A8%80/ class=nav-item>STRIPS</a></li> <li class=toctree-l3><button class="section nav-item hide">PDDL</button> <ul class="subnav hide"> <li class=toctree-l4><a href=../../PlanLanguages/Extension%20to%20PDDL/ class=nav-item>PDDL扩展</a></li> <li class=toctree-l4><a href=../../PlanLanguages/FOND-QNP%28SAS%2B%29/ class=nav-item>FOND-QNP(SAS+)</a></li> </ul></li> </ul></li> <li class=toctree-l2><button class="section nav-item hide">机器人世界</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../PlanLanguages/Golog/Golog_ROS/ class=nav-item>Golog</a></li> </ul></li> </ul></li> <li class=toctree-l1><button class="section nav-item">PDDL使用</button> <ul class=subnav> <li class=toctree-l2> <a href=../../Usage/LocalSolvers/ class=nav-item>本地环境使用</a></li> <li class=toctree-l2> <a href=../../Usage/OnlineSolver/ class=nav-item>线上求解器使用</a></li> <li class=toctree-l2> <a href=../../Usage/VSCode/ class=nav-item>Visual Studio Code使用</a></li> <li class=toctree-l2><a href=../../Usage/FFPlanner_demo/ class=nav-item>ffPlanner_demo</a></li> <li class=toctree-l2><button class="section nav-item hide">经典demos</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../SolversBaseOnPDDL/%E5%88%8A%E7%89%A9%E4%B8%8A%E7%BB%8F%E5%85%B8demos/ class=nav-item>刊物上经典demos</a></li> <li class=toctree-l3><a href=../../SolversBaseOnPDDL/PDDL%20Benchmark%20Instances/ class=nav-item>BenchMark</a></li> </ul></li> </ul></li> <li class=toctree-l1><button class="section nav-item">PDDL语法</button> <ul class=subnav> <li class=toctree-l2> <a href=../../Syntax/PDDL%20axioms/ class=nav-item>语法总览</a></li> <li class=toctree-l2> <a href=../../Syntax/PDDLParser/ class=nav-item>Parser</a></li> </ul></li> <li class=toctree-l1><button class="section nav-item">PDDL-Descripted AI Planning World</button> <ul class=subnav> <li class="toctree-l2 current"><button class="section nav-item">Papers</button> <ul class=subnav> <li class=toctree-l3><a href=../A%20review%20of%20generalized%20planning/ class=nav-item>reviewOfGP</a></li> <li class=toctree-l3><a href=../GP_summary/ class=nav-item>GP_summary</a></li> <li class=toctree-l3><a href=../A%20Review%20of%20Machine%20Learning%20for%20Automated%20Planning/ class=nav-item>ReviewOfMLforAP</a></li> <li class="toctree-l3 current"><a href=./ class="nav-item current">GPwithDeep-RL</a> <ul class=subnav> <li class=toctree-l4><a class="nav-item toc" href=#11>1.1. 相关工作</a></li> </ul></li> <li class=toctree-l3><a href=../Survey%20of%20research%20literature/ class=nav-item>researchSurvey</a></li> </ul></li> <li class=toctree-l2><button class="section nav-item hide">SolversBaseOnPDDL</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../SolversBaseOnPDDL/PyperPlan_STRIPS/ class=nav-item>PyperPlan_STRIPS</a></li> <li class=toctree-l3><a href=../../SolversBaseOnPDDL/Solvers/ class=nav-item>Solvers</a></li> <li class=toctree-l3><button class="section nav-item hide">CP</button> <ul class="subnav hide"> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/CP/ffPlaner/ class=nav-item>FF</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/CP/fast-downward/ class=nav-item>FD</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/CP/LAPKT%E8%BD%BB%E9%87%8F%E8%87%AA%E5%8A%A8%E8%A7%84%E5%88%92%E5%B7%A5%E5%85%B7%E5%8C%85/ class=nav-item>LAPKT轻量自动规划工具包</a></li> </ul></li> <li class=toctree-l3><button class="section nav-item hide">GP_Numerical</button> <ul class="subnav hide"> <li class=toctree-l4> <a href=../../SolversBaseOnPDDL/GP_Numerical/QNP_ReduceTo_GraphProblem/ class=nav-item>QNP_ReduceTo_GraphProblem</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/%E5%9B%BE%E6%B3%95QNP/ class=nav-item>图法QNP</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/LPG%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E8%A7%84%E5%88%92%E5%9B%BE%EF%BC%89/ class=nav-item>LPG</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/grahPlan/ class=nav-item>grahPlan</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/SGPlan6/ class=nav-item>SGPlan6</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/PRP/ class=nav-item>PRP</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/myND/ class=nav-item>myND</a></li> </ul></li> <li class=toctree-l3><button class="section nav-item hide">QNP_FONS_SAT</button> <ul class="subnav hide"> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/QNP_FONS_SAT/CNF_py/ class=nav-item>CNF_py</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/QNP_FONS_SAT/FOND/ class=nav-item>FOND</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/QNP_FONS_SAT/QA_FOND/ class=nav-item>QA_FOND</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/QNP_FONS_SAT/%E4%BE%8B%E8%A7%A3FOND%2BCNF/ class=nav-item>例解FOND</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/QNP_FONS_SAT/QNP/ class=nav-item>QNP</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/QNP_FONS_SAT/qnp2fond/ class=nav-item>qnp2fond</a></li> <li class=toctree-l4><a href=../../SolversBaseOnPDDL/GP_Numerical/QNP_FONS_SAT/QNP2SAT/ class=nav-item>QNP2SAT</a></li> </ul></li> </ul></li> <li class=toctree-l2><button class="section nav-item hide">PDDL-plan-validators</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../Extensions/PDDL-plan-validator/PDDL-plan-validator/ class=nav-item>validators</a></li> <li class=toctree-l3><a href=../../Extensions/PDDL-plan-validator/Lisp-pddl-INVAL-validator/ class=nav-item>INVAL</a></li> <li class=toctree-l3><a href=../../Extensions/PDDL-plan-validator/VScode-PDDL%E6%8F%92%E4%BB%B6VAL/ class=nav-item>VAL</a></li> </ul></li> <li class=toctree-l2><button class="section nav-item hide">PDDL-Auto Planning</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../Extensions/AP/PDDL4j_Java%20for%E8%87%AA%E5%8A%A8%E8%A7%84%E5%88%92/ class=nav-item>PDDL4j</a></li> <li class=toctree-l3><a href=../../Extensions/AP/Tarski%20-%20An%20AI%20Planning%20Modeling%20Framework/ class=nav-item>Tarski</a></li> <li class=toctree-l3><a href=../../Extensions/AP/%E5%AE%9E%E4%BE%8B%E4%B8%AD%E5%AD%A6%E4%B9%A0QNP%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0AP%28AutomatedPlanning%29/ class=nav-item>QNP2AP</a></li> <li class=toctree-l3><a href=../../Extensions/RL/PDDLGYM/ class=nav-item>PDDLGYM</a></li> <li class=toctree-l3><a href=../../Extensions/RL/RLPlanPapers/ class=nav-item>PDDL+RL强化学习</a></li> </ul></li> </ul></li> <li class=toctree-l1><button class="section nav-item">进击的PDDL</button> <ul class=subnav> <li class=toctree-l2><button class="section nav-item hide">Curry-Howard correspondence</button> <ul class="subnav hide"> <li class=toctree-l3><a href=../../FurtherMore/%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BECFG%E8%AF%AD%E4%B9%89%E7%BD%91%E7%BB%9Cpetri%E8%BF%81%E7%A7%BB%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8/ class=nav-item>CFG语义网络</a></li> <li class=toctree-l3><a href=../../FurtherMore/PDDL-Solver2AST/ class=nav-item>PDDL-Solver2AST</a></li> <li class=toctree-l3><a href=../../FurtherMore/TransitionSystemModelCheck/ class=nav-item>CFG=TransitionSystemModelCheck.md</a></li> <li class=toctree-l3><a href=../../FurtherMore/qnp2ast2program/ class=nav-item>qnp2ast2program</a></li> </ul></li> </ul></li> <li class=toctree-l1> <a class=nav-item href=https://github.com/Tridu33/ZERO-Starting-AI-Planning-in-PDDL-Descripted-World/issues>Issue跟踪讨论</a></li> </ul> </nav> <div class=repo> <div class=link> </div> <div class=previous><a href=../A%20Review%20of%20Machine%20Learning%20for%20Automated%20Planning/ >&laquo; Previous</a></div> <div class=next><a href=../Survey%20of%20research%20literature/ >Next &raquo;</a></div> </div> </aside> <div id=spacer><button class=arrow></button></div> <main> <div class=home-top> <button class=hamburger></button> <a href=../.. class=site-name> AI Planning in PDDL-Descripted World</a> </div> <div id=main> <nav class=breadcrumbs> <ul> <li>PDDL-Descripted AI Planning World &raquo; </li><li>Papers</li> </ul> </nav> <div id=content><div class=toc> <ul> <li><a href=#1-generalized-planning-with-deep-reinforcement-learning>1. Generalized Planning With Deep Reinforcement Learning</a><ul> <li><a href=#11>1.1. 相关工作</a><ul> <li><a href=#111-2>1.1.1. 2背景</a><ul> <li><a href=#1111-21>1.1.1.1. 2.1经典规划</a></li> <li><a href=#1112>1.1.1.2. 强化学习</a></li> </ul> </li> <li><a href=#112-generalized-policy>1.1.2. **学习generalized policy</a><ul> <li><a href=#1121-31>1.1.2.1. 3.1状态表示</a></li> <li><a href=#1122-32>1.1.2.2. 3.2图形嵌入</a></li> <li><a href=#1123-33>1.1.2.3. 3.3政策代表</a></li> <li><a href=#1124-34>1.1.2.4. 3.4程序训练</a></li> <li><a href=#1125-35>1.1.2.5. 3.5推理过程中的计划</a></li> </ul> </li> <li><a href=#113-5>1.1.3. 5个实验</a><ul> <li><a href=#1131-51>1.1.3.1. 5.1域</a></li> <li><a href=#1132-52>1.1.3.2. 5.2实验设定</a></li> <li><a href=#1133-53>1.1.3.3. 5.3基准</a></li> <li><a href=#1134-54>1.1.3.4. 5.4评估指标</a></li> <li><a href=#1135-55>1.1.3.5. 5.5结果</a></li> </ul> </li> <li><a href=#114>1.1.4. 结论与未来工作</a></li> </ul> </li> </ul> </li> </ul> </div> <h1 id=1-generalized-planning-with-deep-reinforcement-learning>1. Generalized Planning With Deep Reinforcement Learning<a class=headerlink href=#1-generalized-planning-with-deep-reinforcement-learning title="Permanent link">&para;</a></h1> <p>深度强化学习和图神经网络的使用，以学习此类广义策略，并证明它们可以推广到实例上，这些实例比在其上进行训练的实例大几个数量级</p> <p>古典计划与查找计划或动作序列有关，当将这些计划或动作序列应用于一组逻辑谓词所指定的某些初始条件时，会将环境带入满足一组目标谓词的状态。这通常是通过某种启发式搜索过程执行的，生成的计划仅适用于已解决的特定实例。但是，可能会有更好的结果是找到某种更高级别的计划，该计划可以解决许多属于同一域的实例，从而共享一个基础结构。可以发现这种更高级别计划的方法的研究称为通用计划。通用计划不一定适用于所有经典计划领域，但是在仅希望找到目标令人满意的解决方案的情况下，针对可能的领域找到此类解决方案可以避免执行计算密集型搜索的需求。为了给出这样一个广义计划的例子，让我们考虑一个简化的Blocksworld域。在这个领域中，有一些独特的块可以相互堆叠或散布在地板上，并且目标是堆叠和堆叠块，以便我们从初始配置中得出目标配置。寻找一个可以以最佳步骤做到这一点的计划通常很难做到 在这个领域中，有一些独特的块可以相互堆叠或散布在地板上，并且目标是堆叠和堆叠块，以便我们从初始配置中得出目标配置。寻找一个可以在最佳步骤中完成的计划通常很难做到 在这个领域中，有一些独特的块可以相互堆叠或散布在地板上，并且目标是堆叠和堆叠块，以便我们从初始配置中得出目标配置。寻找一个可以以最佳步骤做到这一点的计划通常很难做到[<a href=#bookmark5>10]</a>，但是可以通过以下方式在多项式时间内找到一个可以满足目标且不考虑成本的计划：</p> <p>1.拆开所有积木，使其散落在地板上</p> <p>2.根据目标配置，从较低的块开始堆叠块</p> <p>这种策略不是最佳方法，因为我们可能会根据目标规范对已经放置在适当位置的块进行堆叠，但是对于简化后的Blocksworld域中的每个实例，它都会产生一个满足目标的计划。这样的笼统策略也可以被认为是一种策略，它增加了通过强化学习它的可能性。</p> <p>学习。机器学习理论通常假设我们的训练数据分布可以代表测试数据分布，从而证明我们的期望是我们的模型可以很好地推广到测试数据。在一般的计划中，情况并非如此，因为我们的测试实例可能比训练实例大得多，因此远远超出了训练范围。在这项工作中，我们表明，以神经网络体系结构的形式具有**正确的**归纳偏差可以导致模型有效地学习类似于一般原理的策略，并且可以解决比训练过程中遇到的问题大几个数量级的问题。</p> <h2 id=11>1.1. <strong>相关工作</strong><a class=headerlink href=#11 title="Permanent link">&para;</a></h2> <p>多年来，学习计划一直是研究的活跃话题，采用不同的方法尝试学习完整求解器的不同方面。一些工作尝试使用其他独立于域的启发式方法生成的特征来学习特定域的状态的启发式值，例如[<a href=#bookmark39>28]</a>，该功能通过回归来学习启发式值。[<a href=#bookmark40>7]</a>等最新作品通过使用RankSVM [<a href=#bookmark41>13]</a>学习对后继国家进行排名。。这些类型的方法没有从问题描述中明确使用状态或目标信息，而是学习使用手工制作的功能，此外，也没有针对可用操作学习明确的计划策略。与此相反，我们的方法学习针对明确状态和目标的计划策略，这些策略和策略直接选择要采取的行动。</p> <p>其他工作，例如[<a href=#bookmark42>23]</a>，[<a href=#bookmark43>8]</a>和[<a href=#bookmark44>9]</a>，使用问题的实际状态作为输入和深度卷积神经网络，学习了针对操作的明确计划策略，但是依赖于对问题的直观表示。这将它们的使用限制为可以使用视觉表示的域。另一个局限性是[<a href=#bookmark42>23]</a>和[<a href=#bookmark43>8]</a>另外还依赖于计划算法生成的成功计划，并使用模仿学习来学习策略，而</p> <p>[<a href=#bookmark44>9]</a>为此目的使用强化学习。我们的工作不依赖于视觉表示或通过规划算法生成的成功计划，而是通过**深度强化学习通过反复试验直接从PDDL表示中学习问题**。</p> <p>一些工作已经开始研究状态图表示的使用以及不同种类的图神经网络在学习策略或启发式方法方面的用途。在[<a href=#bookmark45>24]</a>作者提出了一种独特的神经网络，称为动作模式网络（ASNet），该网络由交替的动作层和命题层组成，以学习计划策略。它们将状态表示为图形，在图形中对象和动作相互连接，并来回传播信息以最终输出动作的概率。他们通过模仿其他计划者生成的计划来训练自己的ASNet，并使用与领域无关的启发式值来增加输入，以提高性能。在他们的实验中，他们主要关注随机计划问题，并证明他们训练有素的策略可以推广到比训练有素的更大的实例。ASNet的局限性是其固定的接受领域，这限制了他们对长链进行推理的能力，而我们的工作无法分享这一点。</p> <p>在最近的一篇论文中，[<a href=#bookmark46>20]</a>提出了[<a href=#bookmark17>4]</a>的扩展到超图，并用它来学习表示规划问题的删除松弛状态的超图的启发式方法。他们使用计划算法生成的最佳启发式值的有监督学习，然后将所得的神经网络用作搜索算法中的启发式函数。与此相反，我们的方法侧重于学习策略，因为在神经网络上需要进行一次正向传递才能在每种状态下做出决定，因此在评估过程中可以节省更多时间。使用启发式估计需要估计状态的所有后继状态，以便选择最佳操作，这可能会增加运行时间。另一个区别是我们的工作直接在状态上进行，而不是删除松弛，这可能会限制启发式方法的功能，因为省略了一些信息。[<a href=#bookmark47>15]</a>，[<a href=#bookmark48>29]</a>和[<a href=#bookmark49>5]</a>。</p> <h3 id=111-2>1.1.1. <strong>2背景</strong><a class=headerlink href=#111-2 title="Permanent link">&para;</a></h3> <h4 id=1111-21>1.1.1.1. <strong>2.1经典规划</strong><a class=headerlink href=#1111-21 title="Permanent link">&para;</a></h4> <p>古典计划使用从STRIPS建模语言[<a href=#bookmark9>6]</a>派生而来的正式描述语言，称为计划领域定义语言（PDDL）[<a href=#bookmark8>14]</a>，以定义问题领域及其相应的状态和目标。我们关注的是令人满意的计划任务，它可以由集合*（F，O，I，G）定义*，其中*F*是一组命题（或谓词），它们描述任务实例中存在的对象的属性及其关系，<em>O*是一组运算符（或操作类型），ICF是初始状态，而GCF是目标状态的集合。每个动作类型GO都由三元组</em>（Pre（o），Add（o），Del（o））定义，<em>其中前提为*Pre（o）*是一组谓词，这些谓词必须具有正确的值才能适用于该操作，*Add（o）*是一组谓词，在应用后该行为将变为真，而Del（o）是一组谓词，该行为将变为false根据申请。我们试图找到一个计划或一系列行动，这些行动或行动序列一旦应用，就会在一定时限或预定数量的步骤内导致状态为*G</em> C的状态。查找计划任务的计划通常是通过启发式搜索方法来完成的，但是，在这项工作中，我们专注于学习反应式计划策略，这些策略可以在特定领域的实例上进行训练，然后推广到同一领域中新的看不见的实例。</p> <h4 id=1112>1.1.1.2. <strong>强化学习</strong><a class=headerlink href=#1112 title="Permanent link">&para;</a></h4> <blockquote> <p>不同于常见的<span class=arithmatex>\(&lt;S,A,R,P,\gamma \text{折扣率}&gt;\)</span></p> </blockquote> <p>强化学习（RL）是机器学习的一个分支，处理顺序决策问题的学习策略。RL算法最常假设可以将问题建模为马尔可夫决策过程（MDP），在有限水平情况下由元组（S，A，<em>R，P</em> ，<em>T</em> ，p）定义，其中*S*是状态，A是动作集合，<em>R*是将状态或状态动作映射到标量奖励的奖励函数，P是过渡概率函数，使得<span class=arithmatex>\(p（s' | s,a）= P（s'，s， a）\)</span>*</em>（确定性策略=1）**，T是任务范围，*p*是初始状态的分布。</p> <p>在较大的状态和动作空间的情况下，我们不能希望将我们的策略表示为表格(<strong>Q表格</strong>)，因此被迫使用函数逼近器（<strong>Deep Q network 的target network</strong>）来表示带有某些参数*6*的策略*。*我们专注于随机策略，该策略映射状态和动作概率，例如p（a | s）-（a | s），并使用基于策略梯度的方法进行优化</p> <p>我们的政策[<a href=#bookmark11>27]</a>。策略梯度方法使用蒙特卡洛采样估计目标函数相对于策略参数的梯度。在实施策略梯度方法时，我们可以通过使用样本轨迹计算出的“伪损失”的梯度来估算策略梯度</p> <p>近端策略优化（PPO）[<a href=#bookmark13>19]</a>是一种基于策略梯度的算法，旨在通过对收集到的数据进行多次梯度更新，然后丢弃它来收集更多数据，从而更好地利用在学习过程中收集到的数据。为了避免可能因较大的策略更新而引起的稳定性问题，PPO使用特殊的裁剪目标来阻止当前策略与数据收集策略之间的差异，从而定义优化问题</p> <h3 id=112-generalized-policy>1.1.2. **学习generalized policy<a class=headerlink href=#112-generalized-policy title="Permanent link">&para;</a></h3> <h4 id=1121-31>1.1.2.1. <strong>3.1状态表示</strong><a class=headerlink href=#1121-31 title="Permanent link">&para;</a></h4> <p>我们选择将我们状态中的状态表示为图形，并使用特征编码给定状态中对象之间的属性和关系。我们的框架在PDDL建模语言指定的问题域上运行，在该问题域中，问题实例由对象列表和谓词列表定义，这些谓词描述这些对象的属性以及当前状态下它们之间的关系。我们将自己限制在谓词的Arity不超过2的域中，这并不是一个重大限制，因为在许多情况下，较高Arity谓词可以分解为几个较低Arity谓词。我们的图由全局特征，节点特征和边缘特征组成，如[<a href=#bookmark17>4]所示</a>。我们表示全局特征*U* ，节点V和边*E.*全局特征表示问题实例或实体的属性对于该域而言是唯一的，例如Blocksworld域中的指针，并由该域的0度谓词确定。节点特征表示域中对象的属性（例如它们的类型），并由1-arity谓词确定。最后，边缘特征代表对象之间的关系，并由2 arar谓词确定。</p> <p>当生成PDDL实例状态的图形表示时，将为状态中的每个对象生成一个带有节点的完整图形。对于状态中的每个谓词，将对应的特征分配为二进制值1，并假定所有其他特征均为false，其值为0。为了将目标配置包括在神经网络的输入中，目标谓词几乎被视为另一个状态图，并且将这两个图连接在一起以形成状态目标的单个表示形式。状态图和目标图之间的区别在于，在目标图中，值为0的特征表示没有贡献目标；在状态图中，值为0的特征意味着谓词被分配了错误值。</p> <p>在整个工作中使用的经典规划领域是确定性的和马尔可夫式的，这意味着当前状态拥有所有必需的信息以最佳地解决问题。尽管具有此属性，我们发现</p> <p>除了当前状态外，过去的状态还有助于学习过程并提高对较大实例的泛化能力。尽管这不是严格必要的，但我们的实验表明，此步骤可以在一定程度上帮助政策缓解“来回”行为，这在政策更容易犯错误然后尝试尝试的较大情况下尤其有用。纠正它们。添加此历史记录很简单；我们只需将K个先前状态和当前状态的图连接起来，然后如前所述将目标图连接起来。我们测试了几个这样的历史视野，发现仅添加最后一个状态会带来总体上最佳的性能和通用性。在图<a href=#bookmark18>1中</a>可以看到来自Blocksworld域的状态目标图的示例 和<a href=#bookmark19>2，</a>显示具有3个块的实例。</p> <p><img alt=RL+GP1 src=../_v_images/RL%2BGP1.png></p> <p><img alt=RL+GP2 src=../_v_images/RL%2BGP2.png></p> <h4 id=1122-32>1.1.2.2. <strong>3.2图形嵌入</strong><a class=headerlink href=#1122-32 title="Permanent link">&para;</a></h4> <p>为了使用状态目标的图形表示来学习好的策略，我们首先使用图形神经网络（GNN）将图形的节点，边缘和全局特征嵌入到各自的潜在空间中。GNN在图的不同组件之间执行消息传递，从而允许有用的信息流动。我们使用两种不同类型的GNN块，每种块都在图内实施不同样式的信息流，因此比其他类型更适合某些问题领域。在这两种类型中，更新顺序相似，并采用以下常见形式：</p> <p>1.使用先前的边缘和这些边缘的“原始”节点更新边缘。</p> <p>2.使用先前的节点，传入的更新边和全局特征更新节点。</p> <p>3.使用先前的全局变量和更新的节点的聚合来更新全局变量。</p> <p>我们使用的第一种块类型类似于[<a href=#bookmark17>4]中</a>描述的块类型，因此我们将其命名为**Graph Network块**（GN块）。从数学上讲，此块执行以下操作</p> <p><img alt=RL+GP3 src=../_v_images/RL%2BGP3.png></p> <p>在以上表示中，<sup>是非线性，例如整流线性单元，</sup>是节点方式的最大池操作，并且W，*b*是各自的权重矩阵和偏差。在GN块中，节点不加选择地从其相邻节点接收消息，该消息很好地在整个图上传播一般信息，但在需要时更难传递特定的信息位。</p> <p>第二种类型的块旨在解决GN块的缺点，并为此目的提供了一种关注机制。我们将第二个块命名为**Graph Network Attention块**（GNAT块），与[<a href=#bookmark23>26]</a>的Graph Attention Network不同，它使用的注意力机制类似于[<a href=#bookmark24>25]</a>的Transformer模型。该块执行以下操作：</p> <p>在上面的表示中，^是按节点求和的操作，©是Hadamard乘积，*W*和*b*分别是权重矩阵和偏差。如上所述，通过赋予节点以专注于特定消息的能力，这种类型的块允许某些信息位以更有意的方式在图中传播。在构建我们的GNN模型时，我们可以堆叠这些类型的几个块（及其组合）以获得更深的图嵌入能力。在我们的大多数实验中，我们使用了两个块，两个连续的GN块，或者一个GNAT块，后跟一个GN块。正如我们将在实验部分中展示的那样，每种配置都擅长解决不同的问题。</p> <h4 id=1123-33>1.1.2.3. <strong>3.3政策代表</strong><a class=headerlink href=#1123-33 title="Permanent link">&para;</a></h4> <p>与常规的强化学习基准不同，在常规的强化学习基准中，一组动作是固定的，并且可以通过标准的神经网络体系结构方便地进行处理，而在经典的计划问题中，一组动作取决于状态，并且状态之间的大小不同。在PDDL中，每个域描述都定义了一组动作类型，可以通过将这些动作类型置于状态基础上进行实例化。每种动作类型都接收一组参数，并且为了适用，该动作的参数必须符合一组前提条件。例如，Blocksworld域具有一种称为“拾取”的动作类型，该动作类型将单个块对象作为参数。该块必须是“ clear”，“ on-table”且“ arm-empty”属性必须为true，此操作才适用。可以拾取符合这些前提条件的所有块，并代表唯一的动作。除了先决条件外，每种动作类型还具有在应用动作时引起状态的效果。其中一些影响可能是正面的（状态的某些谓词将采用真值），而某些负面影响（状态的谓词将采用假值）。</p> <p>在计划的每个步骤中，后继状态生成器都会给出当前状态和适用动作的列表。为了以有意义的方式表示动作，使他们能够对其学习策略，我们选择按照动作的效果来描述动作，因为这些是做出决策所必需的要素。由于后继状态生成器在每个步骤都向代理提供了所有法律诉讼，因此我们忽略了前提条件（所有法律诉讼都满足了前提条件）。每个动作都由几种效果组成，每种效果都涉及状态的不同方面，可以是正面的也可以是负面的。根据效果的类型（全局效果，节点效果或边缘效果）将效果聚在一起，和表示为各个组成部分的嵌入和一个热向量的串联，该向量描述哪个谓词已更改以及其为正还是负。这个一元向量在相应输入分量的维度上*（d v*为例如节点效应）并包含1表示正作用或-1在适当的位置谓词的负面影响。每个效果都会根据其类型由多层感知器（MLP）进行转换，然后将已转换的效果分散回其原始动作。将每个动作的效果汇总在一起，以形成该动作的单个向量表示，最终将其馈送到策略神经网络。图<a href=#bookmark26>4</a>说明了动作表示的过程。</p> <p>最终策略是MLP，它为每个动作输出单个标量，然后通过softmax操作对这些标量进行归一化，以获取动作的离散分布。另外，另一个MLP提取图形的最终全局特征嵌入并输出状态的预测值，以用于RL算法中的优势估计。</p> <h4 id=1124-34>1.1.2.4. <strong>3.4程序训练</strong><a class=headerlink href=#1124-34 title="Permanent link">&para;</a></h4> <p>由于这项工作的重点是找到可行的计划，因此我们选择将问题建模为带有二元奖励的稀疏奖励问题。如果代理满足预定范围内的所有目标，则得到1的奖励，如果没有满足，则没有任何奖励。为了确定适当的时限，我们使用了常用的**hff**启发式方法[<a href=#bookmark28>12]</a>，它解决了线性时间问题的松弛形式（松弛问题没有负面影响）。我们采用松弛计划的长度，并将其乘以5的常数以获得地平线的长度。</p> <p>为了训练我们的策略，我们选择使用近端策略优化（PPO）[<a href=#bookmark13>19]，</a>因为它简单易用且性能良好。为了解决稀疏奖励的问题，我们最初使用Hindsight Experience Replay DQN [<a href=#bookmark29>2]</a> 进行了实验，因为它具有解决稀疏目标达成问题的能力，但是发现它引入了很多偏见并导致性能不理想。为了让我们的政策能够从稀疏的二进制奖励中学习，我们采取了一种</p> <p><img alt=RL-GP4 src=../_v_images/RL-GP4.png></p> <p>更简单的方法 我们根据实例大小的分布生成了每个训练情节，实例大小的分布小到足以被随机初始化的策略解决。这样做可以使策略得以发展，最终解决分发中的所有实例大小，而无需手动调整课程表。尽管设置此分布需要手动完成，但我们发现通过使用随机未经训练的神经网络进行简单的试验和错误，可以非常轻松快捷地完成此任务。</p> <p>我们对标准PPO算法进行了一些小调整，从而提高了本例的性能。许多RL算法的实现会在更新模型参数之前针对固定数量的步骤推出策略，通常会在过程完成之前终止情节，并使用诸如Generalized Advantage Estimation [<a href=#bookmark30>18]</a>和自举值估计之类的方法来估计收益<a href=#bookmark31>[16] ]</a>。我们发现这些元素会给我们的学习过程带来不必要的偏见，而是使用经验性回报而不是引导价值估算来计算优势，从而逐步推广每个情节直至终止。我们还发现，使用许多推广和大批量生产有助于稳定学习过程并获得更好的最终性能，因此我们进行了100集的推广，并使用结果数据在每次学习迭代时更新模型参数算法。</p> <h4 id=1125-35>1.1.2.5. <strong>3.5推理过程中的计划</strong><a class=headerlink href=#1125-35 title="Permanent link">&para;</a></h4> <p>为了提高通用策略在测试期间使用额外时间的能力，我们在搜索算法中使用了这些策略，就像[<a href=#bookmark33>21]</a>，[<a href=#bookmark34>3]</a>等其他许多作品中所做的那样。这种类型的合成在诸如Go和Chess [<a href=#bookmark35>22]的</a>零和游戏中获得了巨大的成功，其中深度神经网络策略与蒙特卡洛树搜索算法结合使用，这促使其他作者甚至对非游戏问题[<a href=#bookmark36>1]</a>。我们采用不同的方法，专门针对具有强反应性策略的确定性计划问题设计搜索算法。我们的算法以经典的贪婪最佳优先搜索（GBFS）算法为基础，但是以几种关键方式对其进行了扩充。在标准GBFS中，从根节点构建一个搜索树，并且在每次迭代时，从打开列表中提取启发式估计最佳的节点，进行扩展并将其子节点添加到打开列表中，并重复此过程直到找到目标节点或直到超时为止。我们的算法称为GBFS-GNN，它执行类似的过程，但是使用策略和值函数为每个节点计算启发式值，并为每个扩展节点执行完整部署。扩展节点的后代将添加到打开列表中，但是在转出过程中遇到的其余节点则不是，以避免大问题中内存消耗的快速增长。搜索树中的每个节点代表一个状态-动作对，我们对每个节点使用以下启发式估计</p> <p><img alt=RL+GP5 src=../_v_images/RL%2BGP5.png></p> <h3 id=113-5>1.1.3. <strong>5个实验</strong><a class=headerlink href=#113-5 title="Permanent link">&para;</a></h3> <h4 id=1131-51>1.1.3.1. <strong>5.1域</strong><a class=headerlink href=#1131-51 title="Permanent link">&para;</a></h4> <p>我们评估了五个常见的经典规划领域的方法，这些领域是从IPC规划竞赛集合中选择的，其领域谓词不大于2：</p> <p>•Blocksworld（4 op）：机械手必须从初始配置中移动积木，以便根据目标配置进行排列。</p> <p>•卫星：一组卫星必须拍摄位置的图像，每个图像都具有指定类型的传感器。</p> <p>•物流：必须将包裹运送到目标位置，使用飞机和卡车在城市和地点之间移动包裹。</p> <p>•夹爪：双臂机器人必须将球从A室传送到B室。</p> <p>•渡轮：渡轮必须将汽车从最初的位置运输到指定的目标位置。</p> <p>这五个领域的共同点在于，可以为它们制定简单的通用计划，从而能够解决任意大的实例。我们希望证明我们的方法能够产生解决比实例大得多的实例的策略，从而自动发现这样的广义计划。有些领域比其他领域容易，并且在广义计划很容易描述的情况下，我们经常目睹该政策非常成功地推广。例如，Gripper域具有非常简单的策略（每次到B室都抓住2个球），实际上我们的神经网络学习了最佳策略，即使对于数百个球的实例，通常仍然表现最佳。为了证明我们的政策确实能很好地推广，</p> <p>•对于Blocksworld域，我们在4个块的实例上训练了我们的策略，并在5-100个块的实例上进行了评估。</p> <p>•对于“卫星”领域，我们对使用1-3颗卫星，每颗卫星1-3台仪器，1-3种仪器，2-3个目标的实例进行了政策培训，并针对使用1-14颗卫星，2-11台仪器的实例进行了评估每个卫星，1-6种仪器和2-42个目标。</p> <p>•对于物流领域，我们针对使用2-3架飞机，2-3个城市，每个城市2-3个地点，1-2个包裹的实例训练了我们的策略，并评估了使用4-12架飞机，4-15个城市，1个实例的实例每个城市-6个地点和8-40个包裹。</p> <p>•对于Gripper域，我们针对3个球的实例训练了我们的策略，并针对5-200个球的实例进行了评估。</p> <p>•对于Ferry域，我们针对具有3-4个位置，2-3个汽车的实例训练了我们的策略，并针对具有4-40个位置和2-120个汽车的实例进行了评估。</p> <h4 id=1132-52>1.1.3.2. <strong>5.2实验设定</strong><a class=headerlink href=#1132-52 title="Permanent link">&para;</a></h4> <p>为了训练我们的策略，我们依靠实例生成器来产生随机的训练实例，因为我们的方法需要大量的训练数据。所有策略都经过1000次迭代训练，每个迭代有100个训练情节和多达20个渐变更新步骤。实验是在一台装有i7-8700K处理器和一个NVIDIA GTX 1070 GPU的计算机上进行的。我们对所有五个域使用了相同的训练超参数，但神经网络模型略有不同。我们使用了256个隐藏表示形式和ReLU激活，一个学习率0.0001，一个折现因子0.99，一个熵奖励0.01，一个剪切比0.2和一个KL发散角参数0.01。对于Blocksworld和Gripper域，我们使用了两层GNN，两层都是GN块类型，对于Satellite，渡轮和物流领域，我们使用了两层GNN，其中包含一个GNAT块和一个GN块。我们的代码是用Python实现的，而神经网络和学习算法是使用PyTorch实现的[<a href=#bookmark53>17]</a>。</p> <h4 id=1133-53>1.1.3.3. <strong>5.3基准</strong><a class=headerlink href=#1133-53 title="Permanent link">&para;</a></h4> <p>我们的评估重点是解决广义规划域的大型实例，并将我们的方法与经典规划器进行比较。其他基于学习的方法或者在撰写本文时没有可用的代码（例如 [<a href=#bookmark46>20]</a>），或者固有地在扩展到大问题时受到限制（例如[<a href=#bookmark45>24]</a>），因此我们选择了更通用的基准经典计划器的形式，如果有足够的时间和内存，它可以扩展到大问题。我们与**Fast-Downward**快速下降比较[<a href=#bookmark55>11]</a>，这是最新的框架。我们的方法使用Pyper plan作为模型和后继状态生成器，它是基于Python的框架。我们使用LAMA优先配置作为快速向下的设置，因为它是性能最高的竞争性满意计划算法。</p> <p><img alt=RL-GP6 src=../_v_images/RL-GP6.png></p> <p><img alt=RL-GP7 src=../_v_images/RL-GP7.png></p> <h4 id=1134-54>1.1.3.4. <strong>5.4评估指标</strong><a class=headerlink href=#1134-54 title="Permanent link">&para;</a></h4> <p>由于我们的工作集中在令人满意的计划上，因此我们将成功率用作主要指标。我们对每个域在一组50个伸出的评估实例上运行GBFS-GNN和快速向下，并针对每个实例在600秒的固定时间限制内运行每种方法，然后针对时间绘制每种方法的成功率限制和限制扩展状态的数量，以查看每种方法如何在给定的计算下进行缩放。根据广泛的分布生成评估实例，以便对大小实例进行采样。</p> <h4 id=1135-55>1.1.3.5. <strong>5.5结果</strong><a class=headerlink href=#1135-55 title="Permanent link">&para;</a></h4> <p>现在，我们介绍我们的结果。图<a href=#bookmark58>6</a>显示了我们的方法与实验中使用的五个域的快速向下比较之间的比较。这些图显示了成功率与扩展状态数的函数关系，并表明与5个域中的4个领域的经典规划器相比，我们的方法的缩放比例确实有利。实际上，在我们的政策普遍推广的4个领域中，GBFS-GNN几乎不需要搜索。在这些领域中，除了最困难的情况外，只要贪婪地遵循策略即可找到解决方案。我们的搜索算法建立在这种泛化能力的基础上，并在搜索时使用了少量的完整策略部署。</p> <p>在图<a href=#bookmark59>7中，</a>我们比较了我们的方法和快速向下方法，并针对给定的运行时间绘制了成功率。我们可以看到，即使快速向下版本具有高度优化的C ++实现，并使用复杂的建模工具来有效地解决计划问题，我们的方法还是在一个领域（Blocksworld）中克服了它，而在其他三个领域中将其紧密匹配。尽管GBFS-GNN使用的后继状态和法律行动生成器的速度比快速向下的速度慢几个数量级，但我们的方法5的泛化能力使其与经典计划程序的最新实现方式相比具有竞争力。</p> <p>关于我们的方法的泛化性能的一个明显例外是物流领域。我们的策略在训练实例上成功取得了良好的性能，但是未能推广到更大的实例尺寸，因此在该领域的快速降级远远超出了我们的策略。在域中，物流域在每个实例中的不同对象之间包含更紧密的耦合。例如，在“卫星”域中，从策略可以具有多个“半熟”目标并在它们之间进行切换而不会受到干扰的意义上说，校准仪器或对目标成像不会干扰其他卫星。在物流领域，这是不可能的，因为所有包裹都共享卡车和飞机，并且移动特定卡车来捡拾包裹可能会干扰原本打算在另一个位置捡拾的另一个包裹。不同的图神经网络体系结构可能会鼓励该策略在单个目标上保持“固定”，直到满足为止再转向另一个目标，从而有可能解决物流领域和其他类似类型的问题。</p> <h3 id=114>1.1.4. <strong>结论与未来工作</strong><a class=headerlink href=#114 title="Permanent link">&para;</a></h3> <p>在这项工作中，我们研究了图神经网络和深度强化学习算法学习通用规划策略的能力，该规划策略可以解决比训练过程中遇到的实例大得多的实例，从而有效地推广了原理。与某些其他方法不同，我们的方法**不依赖于现有**计划人员提供的最佳解决方案，也**不依赖于启发式方法**来提高性能。我们进一步介绍GBFS-GNN，这是一种搜索算法，可利用高性能反应策略的可用性来快速找到超大型实例的解决方案。</p> <p>我们的策略是通过强化学习从头开始学习的，并与GBFS-GNN结合使用，可以实现性能，在扩展状态方面超越了最先进的状态规划师的高度优化实现，并且在运行时间方面可以与之媲美。</p> <p>相关<sup id=fnref:LOGIC><a class=footnote-ref href=#fn:LOGIC>1</a></sup>和文献<sup id=fnref:POMC><a class=footnote-ref href=#fn:POMC>2</a></sup>。</p> <p><strong>参考</strong></p> <div class=footnote> <hr> <ol> <li id=fn:LOGIC> <p>GICystems&#160;<a class=footnote-backref href=#fnref:LOGIC title="Jump back to footnote 1 in the text">&#8617;</a></p> </li> <li id=fn:POMC> <p>Checking&#160;<a class=footnote-backref href=#fnref:POMC title="Jump back to footnote 2 in the text">&#8617;</a></p> </li> </ol> </div></div> <footer> <div class=footer-buttons> <div class=previous><a href=../A%20Review%20of%20Machine%20Learning%20for%20Automated%20Planning/ title=ReviewOfMLforAP><span>Previous</span></a></div> <div class=next><a href=../Survey%20of%20research%20literature/ title=researchSurvey><span>Next</span></a></div> </div> <div class=footer-note> <p> Built with <a href=http://www.mkdocs.org>MkDocs</a> using <a href=https://github.com/daizutabi/mkdocs-ivory>Ivory theme</a>. </p> </div> </footer> </div> </main> </div> <script>var base_url = '../..';</script> <script src=../../js/theme.js></script> <script src=../../js/umlconvert.js></script> <script src=../../js/sequence-loader.js></script> <script src=https://unpkg.com/mermaid/dist/mermaid.min.js></script> <script src=https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js></script> <script src=https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.12.0/underscore-min.js></script> <script src=https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js></script> <script src=https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js></script> <script src=../../search/main.js></script> </body> </html>